<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta charset="utf-8"/>
<link href="https://fonts.googleapis.com/css?family=Lateef" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
<title>The Search for a GUI Docker</title>
<link href="../../css/archive.css" type="text/css" rel="stylesheet"/>
<script type="text/javascript" src="../../js/archive.js"></script>
<script type="text/javascript" src="../../js/highlight.js"></script>
</head>

<body class="from_sigil">
  
  <div class="headerdiv">
    <a href="../../index.html">
      <img class="topimg" src="../../images/CD_HeaderBanner.png" alt="LJ Archive"/>
    </a>
  </div>


  <div class="tophrdiv">
  </div>

  
  <div id="top_search">
    <table class="page_search" summary="">
      <tr>
        <td valign="top" align="left">
          <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
        </td>
        <td valign="top" align="right">
          <form method="get" action="/zoom/search.cgi">
            <input type="hidden" name="zoom_sort" value="0" />
            <input type="hidden" name="zoom_xml" value="0" />
            <input type="hidden" name="zoom_per_page" value="10" />
            <input type="hidden" name="zoom_and" value="1" />
            Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
            <input type="submit" value="Submit" />
          </form>
        </td>
      </tr>
    </table>
  </div>

<h1 class="title">The Search for a GUI Docker</h1>

<h2 class="sigil_not_in_toc">
Docker is everything but pretty; let's try to fix that. Here's a rundown of
some GUI options available for Docker. By Shawn Powers</h2>

<p>
I love Docker. At first it seemed a bit silly to me for a small-scale
implementation like my home setup, but after learning how to use it, I fell
in love. The standard features are certainly beneficial. It's great not
worrying that one application's dependencies will step on or conflict
with another's. But most applications are good about playing well with
others, and package management systems keep things in order. So why do I
<code>docker run</code> instead of <code>apt-get install</code>? Individualized system settings.
</p>

<p>
With Docker, I can have three of the same apps running side by side. They
even can use the same port (internally) and not conflict. My torrent
client can live inside a forced-VPN network, and I don't need to worry that it will
somehow "leak" my personal IP data. Heck, I can run apps that work
only on CentOS inside my Ubuntu Docker server, and it just works! In short,
Docker is amazing.
</p>

<p>
I just wish I could remember all the commands.
</p>

<p>
Don't get me wrong, I'm familiar with Docker. I use it for most of my
server needs. It's my first go-to when testing a new app. Heck, I taught
an entire course on Docker for CBT Nuggets (my day job). The problem is,
Docker works so well, I rarely need to interact with it. So, my FIFO
buffer fills up, and I forget the simple command-line options to make
Docker work. Also, because I like charts and graphs, I decided to install
a Docker GUI. It was a bit of an adventure, so I thought I'd share the
ins and outs of my experience.
</p>

<h3 class="sigil_not_in_toc">
My GUI Expectations</h3>

<p>
There are some things I don't really care about for a GUI. Oddly, one of
the most common uses people have for a visual interface is the ability to
create a Docker container. I actually don't mind using the command line
when I'm creating a container, because it usually takes 5–10 attempts
and tweaks before I get it how I want it. So for me, I'd like to have
at least the following features:
</p>

<ul><li>
A visual layout of all containers, whether or not they're running.
</li>

<li>
A way to start/stop/delete containers.
</li>

<li>
The ability to rename running containers, because I always forget to name
them, and I get tired of seeing "chubby_cheetah" for container names.
</li>

<li>
A way to change the restart policy easily, so when I finally get a container
right, I can have it <code>--restart=always</code>.
</li>

<li>
Show some statistics about the system and individual containers.
</li>

<li>
Read logs.
</li>

<li>
Work via web interface, so I can use it remotely.
</li>

<li>
Be a Docker container itself!
</li>
</ul>

<p>
My list of needs is fairly simple, but oddly, many GUIs left me
wanting. Since everyone's desires are different, I'll go over the most
popular options I tried, and mention some pros and cons.
</p>

<h3 class="sigil_not_in_toc">
Kitematic</h3>

<p>
It has a strange name, but Kitematic has been around for a very
long time. It actually was adopted officially by Docker, and it's
now part of the Docker Toolkit. It's a fairly simple interface, but
simplicity is sometimes a bonus, because finding the things it can do
is straightforward.
</p>

<p>
If you check out the <a href="http://kitematic.com">Kitematic website</a>,
you might
get the impression it runs only on OS X or Windows, but thankfully, that's
not the case. If you head over to the <a href="https://github.com/docker/kitematic/releases">GitHub repository</a>, you'll find an
Ubuntu installer as well. 
</p>

<p>
Kitematic is pretty, but it's a native application, not a web
interface. It looks nice (Figure 1), but I'm often on someone else's
computer when I'm out and about, so my web-based requirement is really
vital. Still, if you don't need a web interface and want a supported,
clean GUI, Kitematic is pretty slick. It's fairly simple, but again,
that's not a bad thing.
</p>
<div class="caption">
<img alt="Kitematic screen" src="12492f1.jpg"/>

<p class="caption"><em>Figure 1. Kitematic looks incredibly nice, but it's unfortunately a native
non-web app (image via <a href="https://kitematic.com">kitematic.com</a>).<!--<em-->
</em></p>
</div>

<em>

<p>
<strong>Pros:</strong>
</p>

<ul><li>
Officially supported by Docker.
</li>

<li>
Very clear and simple interface.
</li>
</ul>

<p>
<strong>Cons:</strong>
</p>

<ul><li>
Not a web app.
</li>
</ul>

<h3 class="sigil_not_in_toc">
DockStation</h3>

<p>
DockStation is another non-web-based solution, but I wanted to mention it
because it's very powerful. It has a great, clean interface (Figure 2), but
again, it requires installation on a local machine. It does have support for
accessing a remote Docker server over SSH, but that still means installing
an application locally, and configuration isn't straightforward.
</p>
<div class="caption">
<img alt="DockStation" src="12492f2.jpg"/>

<p class="caption"><em>Figure 2. DockStation also looks great, but it's proprietary and requires
quite a bit of work to get working. Also, it's not web-based (image via
<a href="https://dockstation.io">dockstation.io</a>).</em></p>
</div>

<p>
Plus, DockStation is closed source. That alone wouldn't be a showstopper
for me, but when added to the frustration of a native application
install, it's enough to turn me off. Still, it is free for personal
use, and especially if you're a developer, DockStation might be
very attractive. There are lots of screenshots on the <a href="https://dockstation.io">website</a> if you want to check it out.
</p>

<p>
<strong>Pros:</strong>
</p>

<li>
Well-designed interface.
</li>

<li>
More powerful than Kitematic and has more features.
</li>

<li>
Supports remote SSH access (but is complex to configure).
</li>


<p>
<strong>Cons:</strong>
</p>

<ul><li>
Not open source.
</li>

<li>
Not web-based.
</li>
</ul>

<h3 class="sigil_not_in_toc">
Portainer</h3>

<p>
The closest thing I found to a perfect solution was Portainer. It's
web-based, runs as a Docker container, and it's easy to get going. On the
surface, it seems fairly basic, but I was impressed to see there is even
a tiered user system, meaning you can give various users different levels of access
to the Docker infrastructure.
</p>

<p>
Portainer doesn't seem to keep historical performance statistics, but
it does have a real-time monitor (Figure 3) that works in a pinch if I'm
trying to troubleshoot a misbehaving container. I'm a little surprised to
find that the application template feature (Figure 4) is one of my favorite
things to play with. I know my original requirements did not include
a way to deploy containers quickly, but grabbing a quick template and
clicking deploy is surprisingly simple, and I find myself playing with
containers more often. It's not that deploying a container via the
command line is hard, but it's a lot of typing; whereas with Portainer,
I simply can click "deploy", and it's all done for me. It seems silly,
but anything that gets me playing with technology is a good thing.
</p>
<div class="caption">
<img alt="Container Graph" src="12492f3.jpg"/>

<p class="caption"><em>Figure 3. I love seeing graphs, and if a container is behaving poorly,
this real-time look at performance is very useful.</em></p>
</div>

<div class="caption">
<img alt="Portainer App Templates" src="12492f4.jpg"/>

<p class="caption"><em>Figure 4. I'm not normally into templates like this, but I kind of felt like
a kid in a candy store here!</em>
</p>
</div>

<p>
If you want a fairly simple interface to your running Docker server,
Portainer is great. It can start and stop containers, edit existing
running apps (and even rename them, something I always have to do), and it's
a great way to clean up your system after a session of adding/removing
images. For example, you can look at the volumes tab (Figure 5) and quickly
identify volumes no longer associated with a running container. It's
something I never think about, so I had hundreds of abandoned volumes
just sitting there.
</p>
<div class="caption">
<img alt="Portainer image" src="12492f5.jpg"/>

<p class="caption"><em>Figure 5. It's not that abandoned volumes were taking up a lot of room
on my system, but I hate leaving things lying around. Portainer made
cleanup easy.</em></p>
</div>

<p>
My go-to system for interacting with running containers is Portainer. It
does what I need in a pinch, runs via web browser, and it has enough features
that it's worth keeping around. It's open source, and it's being actively
developed. I highly recommend it. In fact, one of the best things about
Portainer is how easy it is to set up. The following one-liner will download
the image, get the container going and give you access to the interface on
port 9000:

</p><pre><code>
docker run -d -p 9000:9000 \
-v /var/run/docker.sock:/var/run/docker.sock \
portainer/portainer
</code>
</pre>
<p></p>

<p>
I don't expose that to the internet, but
when I'm out and about, a quick <code>ssh</code> command with a port-forward allows
me full access to the Portainer instance. Thanks to the UNIX socket
system, Portainer directly interacts with Docker, and there aren't any
system configuration changes to make in order to get things done. That
one-liner above is literally all it takes. (And for me, the first order
of business in the GUI is to change the name of the container, because
I always forget to do that when creating one!)
</p>

<p>
The folks at Portainer.io offer a fully functional demo 
<a href="https://demo.portainer.io">here</a> (login is admin:tryportainer), which will give you a
feel for what it can do without deploying it in your own environment. I'll
admit, I've had mixed luck getting the demo to work (it often hangs on
me), so it might be easier to spin up a quick container and check it out on
your own system. Still, offering a demo is nice.
</p>

<p>
<strong>Pros:</strong>
</p>

<ul><li>
Web-based.
</li>

<li>
Simple setup (it runs in a container).
</li>

<li>
Easy to navigate.
</li>

<li>
User management.
</li>
</ul>

<p>
<strong>Cons:</strong>
</p>

<ul><li>
Couldn't figure out how to change the restart policy on containers!
</li>
</ul>

<h3 class="sigil_not_in_toc">
Dockly, the Weird Cousin</h3>

<p>
I'd be remiss not to mention one more interesting option, which is technically
a GUI, although not in the traditional sense. Dockly is a GUI, but it's
a Curses-based text GUI. Basically, if Kyle Rankin were looking for a
GUI interface to Docker, Dockly likely would be his first choice. Heck,
it even looks a bit like Mutt (Figure 6).
</p>
<div class="caption">
<img alt="Dockly screen" src="12492f6.jpg"/>

<p class="caption"><em>Figure 6. Dockly isn't the prettiest GUI for Docker, but it does most of
the same things the other GUIs do, and it functions completely inside a
terminal window. It's worth a look.</em></p>
</div>

<p>
Admittedly, navigating the GUI via the keyboard is a bit cumbersome
at first. It took me a while to get the feel for what Dockly
really can do. Once I got used to the interface, however, I must admit it's
pretty nice. Of all the management systems, it's definitely the easiest
to connect with, because it runs in an SSH window.
</p>

<p>
For instructions on how to set up and use Dockly, head over to the <a href="https://github.com/lirantal/dockly">GitHub
page</a>. It uses node.js, which has
been an issue for me in the past regarding conflicting versions. But
since this is Docker, it can, of course, be run in its own container,
making sure it has the exact version it needs.
</p>

<p>
<strong>Pros:</strong>
</p>

<ul><li>
Runs from a container.
</li>

<li>
Easy to set up.
</li>

<li>
Kyle Rankin-friendly (terminal window only).
</li>
</ul>

<p>
<strong>Cons:</strong></p>

<ul><li>
Limited ability to modify containers.
</li>
</ul>

<h3 class="sigil_not_in_toc">
My Final Thoughts</h3>

<p>
You know how sometimes you search the internet for the name of a
particular actor, and then three hours later find yourself watching YouTube
videos of cats getting scared by cucumbers? Well, my dive in to the
world of Docker GUI interfaces was something like that. Portainer was
one of the first I tried, and it ended up being the best. Still, I spent
more than five hours installing and configuring various GUIs, ranging from the
now defunct "Shipyard" to the extremely advanced "Rancher". Many were
native applications, several required additional VMs installed locally
in order to run, and most were more complicated than I wanted.
</p>

<p>
I honestly wish Kitematic was a web-based GUI, because its integration
with Docker is nice, and its simplistic look makes it easy to manage
a simple infrastructure. If you're at the same computer all the time,
checking out a native-GUI option might be worth your time. In the end,
even though I have Portainer and Dockly running, I actually find myself
<code>ssh</code>-ing into my Docker server and running commands by hand. It can be
cumbersome, and I don't always remember the particular arguments. Still,
it's just as easy to google for the answer as it is to log in to a GUI.
</p>

<p>
But the graphs—the graphs are awful nice to look at!
</p>

<h3 class="sigil_not_in_toc">About the Author</h3>
<div class="authorblurb">
<p>
Shawn Powers is Associate Editor here at <em>Linux Journal</em>, and has been
around Linux
since the beginning. He has a passion for open source, and he loves to
teach. He
also drinks too much coffee, which often shows in his writing.
</p>
<img alt="Shawn Powers" src="12492aa.jpg"/>
</div>
</em>

  <div class="toclinks">
    <a class="link1" href="../tocindex.html">Archive Index</a>
    <a class="link2" href="../289/toc289.html">Issue Table of Contents</a>
    <a class="link3" href="../289/12492.html">Article</a>
  </div>
  <div class="bottomhrdiv"></div>

  <div id="bottom_search">
    <table class="page_search" summary="">
      <tr>
        <td valign="top" align="left">
          <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
        </td>
        <td valign="top" align="right">
          <form method="get" action="/zoom/search.cgi">
            <input type="hidden" name="zoom_sort" value="0" />
            <input type="hidden" name="zoom_xml" value="0" />
            <input type="hidden" name="zoom_per_page" value="10" />
            <input type="hidden" name="zoom_and" value="1" />
            Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
            <input type="submit" value="Submit" />
          </form>
        </td>
      </tr>
    </table>
  </div>
  <div class="footerdiv">
    <a href="../../index.html">
      <img class="bottomimg" src="../../images/CD_FooterBanner.png" alt="LJ Archive"/>
    </a>
  </div>

  <div class="copyright">
    Copyright &copy; 1994 - 2018 <cite>Linux Journal</cite>.  All rights reserved.
  </div>
</body>
</html>